Entendido. Para adaptar el c√≥digo y que maneje **XML** en lugar de objetos **JSON/JavaScript**, necesitamos cambiar la forma en que se estructuran y acceden los datos.

En JavaScript del lado del cliente (navegador), el manejo de XML se realiza t√≠picamente con el objeto **`DOMParser`** para analizar (parsear) la cadena XML en un objeto **`Document`** (que representa el DOM de XML). Luego, se utilizan m√©todos de manipulaci√≥n del DOM (como `getElementsByTagName` o `querySelector`) para acceder a los datos.

Aqu√≠ est√° el c√≥digo adaptado:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../img/uneweb.png">
    <title>Ejemplo09 XML</title>
</head>
<body>
    <script>
        // 1. Definici√≥n de los datos en formato XML (como una cadena de texto)
        const xmlData = `
            <estudiantes>
                <estudiante>
                    <id>1</id>
                    <nombre>ANA</nombre>
                    <apellido>VASQUEZ</apellido>
                    <edad>60</edad>
                    <sexo>F</sexo>
                    <estatura>1.65</estatura>
                    <peso>65</peso>
                </estudiante>
                <estudiante>
                    <id>2</id>
                    <nombre>YOLANDA</nombre>
                    <apellido>TORTOZA</apellido>
                    <edad>45</edad>
                    <sexo>F</sexo>
                    <estatura>1.69</estatura>
                    <peso>57</peso>
                </estudiante>
                <estudiante>
                    <id>3</id>
                    <nombre>NELLY</nombre>
                    <apellido>CONTRERAS</apellido>
                    <edad>56</edad>
                    <sexo>F</sexo>
                    <estatura>1.68</estatura>
                    <peso>60</peso>
                </estudiante>
            </estudiantes>
        `;

        // 2. Parsear la cadena XML para obtener un objeto Document (XML DOM)
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, "text/xml");

        // *************** L√≥gica de Acceso y Lectura de Datos ***************

        // 3. Obtener todos los nodos de 'estudiante'
        const estudiantesXML = xmlDoc.getElementsByTagName('estudiante');

        // El objeto estudiantesXML es una NodeList (similar a un array de nodos)
        console.log(estudiantesXML);

        // 4. Iterar sobre los nodos y acceder a la informaci√≥n
        for (let i = 0; i < estudiantesXML.length; i++) {
            const estudiante = estudiantesXML[i];
            
            // Acceder a los elementos hijos de cada 'estudiante' y obtener su texto
            const id = estudiante.getElementsByTagName('id')[0].textContent;
            const nombre = estudiante.getElementsByTagName('nombre')[0].textContent;
            const apellido = estudiante.getElementsByTagName('apellido')[0].textContent;

            // Mostrar los datos en la consola
            console.log(id, nombre, apellido);
            console.log('---');
        }
    </script>
</body>
</html>
```

-----

## Explicaci√≥n de los Cambios Clave

1.  **Datos en Formato XML**:
      * En lugar de definir objetos de JavaScript (`estudiante0`, `estudiante1`, etc.), los datos se definen como una **√∫nica cadena de texto** (`xmlData`) que contiene la estructura XML.
2.  **Uso de `DOMParser`**:
      * En JavaScript, el m√©todo est√°ndar para convertir una cadena XML en un objeto con el que se pueda interactuar es **`new DOMParser().parseFromString(string, "text/xml")`**. Esto crea el objeto **`xmlDoc`**, que es el *Document Object Model* (DOM) del XML.
3.  **Acceso a los Datos (DOM API)**:
      * Para obtener la lista de estudiantes, usamos **`xmlDoc.getElementsByTagName('estudiante')`**, que devuelve una lista de nodos (una `NodeList`).
      * Dentro del bucle, para acceder a un valor espec√≠fico (como el nombre o el ID), se utiliza el m√©todo **`estudiante.getElementsByTagName('nombre')[0].textContent`**.
          * `getElementsByTagName('nombre')` encuentra el elemento hijo llamado `<nombre>`.
          * `[0]` selecciona el primer (y √∫nico) elemento con ese nombre dentro del nodo actual.
          * `.textContent` extrae el valor de texto dentro de ese elemento (ej. 'ANA').


¬°Excelente\! Adaptar este c√≥digo requiere cambiar la fuente de datos de objetos JavaScript (que simulan JSON) a una **cadena XML** y, lo m√°s importante, modificar la l√≥gica de JavaScript para **analizar (parsear) el XML** y **acceder a sus elementos** usando el DOM (Document Object Model) del XML.

Aqu√≠ est√° el c√≥digo adaptado.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../img/uneweb.png" type="image/x-icon">
    <link rel="stylesheet" href="../bootstrap/bootstrap.min.css">
    <script src="../bootstrap/bootstrap.bundle.min.js"></script>
    <title>Ejemplo11 XML Reporte</title>
</head>
<body>
    <div class="container">
        <h1>Reporte de estudiantes (XML)</h1>
        <table class="table table-bordered table-striped">
            <thead>
                <tr>
                    <th>Id</th>
                    <th>Nombre</th>
                    <th>Apellido</th>
                    <th>Sexo</th>
                    <th>Edad</th>
                    <th>Estatura</th>
                    <th>Peso</th>
                </tr>
            </thead>
            <tbody id="cuerpo_tabla"></tbody>
        </table>
        <script>
            // 1. Definici√≥n de los datos en formato XML (como una cadena de texto)
            const xmlData = `
                <estudiantes>
                    <estudiante>
                        <id>1</id>
                        <nombre>ANA</nombre>
                        <apellido>VASQUEZ</apellido>
                        <edad>60</edad>
                        <sexo>F</sexo>
                        <estatura>1.65</estatura>
                        <peso>65</peso>
                    </estudiante>
                    <estudiante>
                        <id>2</id>
                        <nombre>YOLANDA</nombre>
                        <apellido>TORTOZA</apellido>
                        <edad>45</edad>
                        <sexo>F</sexo>
                        <estatura>1.69</estatura>
                        <peso>57</peso>
                    </estudiante>
                    <estudiante>
                        <id>3</id>
                        <nombre>NELLY</nombre>
                        <apellido>CONTRERAS</apellido>
                        <edad>56</edad>
                        <sexo>F</sexo>
                        <estatura>1.68</estatura>
                        <peso>60</peso>
                    </estudiante>
                </estudiantes>
            `;

            // 2. Parsear la cadena XML para obtener un objeto Document (XML DOM)
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, "text/xml");

            // 3. Obtener todos los nodos de 'estudiante'
            const estudiantesXML = xmlDoc.getElementsByTagName('estudiante');

            let salida = '';

            // 4. Iterar sobre los nodos de estudiante y construir la tabla
            for (let index = 0; index < estudiantesXML.length; index++) {
                const estudiante = estudiantesXML[index];
                
                // Funci√≥n auxiliar para obtener el valor de texto de un tag hijo
                // getElementsByTagName devuelve una lista, seleccionamos el primer elemento [0]
                // y luego obtenemos su contenido de texto (.textContent)
                const getXMLValue = (tagName) => estudiante.getElementsByTagName(tagName)[0].textContent;

                salida += `
                    <tr>
                        <td>${getXMLValue('id')}</td>
                        <td>${getXMLValue('nombre')}</td>
                        <td>${getXMLValue('apellido')}</td>
                        <td>${getXMLValue('sexo')}</td>
                        <td>${getXMLValue('edad')}</td>
                        <td>${getXMLValue('estatura')}</td>
                        <td>${getXMLValue('peso')}</td>
                    </tr>`;
            }

            // 5. Inyectar el HTML generado en el cuerpo de la tabla
            document.getElementById('cuerpo_tabla').innerHTML = salida;
        </script>
    </div>

</body>
</html>
```

-----

## Resumen de la Adaptaci√≥n Clave

La principal diferencia est√° en el manejo de los datos dentro del bloque `<script>`:

1.  **Fuente de Datos**: Las variables individuales (`estudiante0`, `estudiante1`, etc.) se reemplazan por una √∫nica cadena **`xmlData`** que contiene todos los datos estructurados en XML.
2.  **An√°lisis (Parsing)**: Se utiliza el objeto **`DOMParser`** para convertir la cadena `xmlData` en un **`xmlDoc`** (el DOM de XML), que JavaScript puede manipular.
    ```javascript
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlData, "text/xml");
    ```
3.  **Acceso a los Datos**:
      * Para obtener la lista de registros, se usa **`xmlDoc.getElementsByTagName('estudiante')`**.
      * Dentro del bucle, para acceder a un campo espec√≠fico (ej., `nombre`), ya no usamos la notaci√≥n de punto (`estudiantes[index].nombre`), sino la API del DOM: **`estudiante.getElementsByTagName('nombre')[0].textContent`**. Este m√©todo navega desde el nodo actual (`estudiante`) hasta el nodo hijo deseado y extrae su texto.


¬°Como experto en JavaScript, aqu√≠ tienes la expresi√≥n regular (Regex) que cumple con todos los requisitos solicitados\!

La expresi√≥n regular es la siguiente:

$$\text{/^(?=.*[0-9])(?=.*[\*_\$\.\#\?\¬ø\-])[A-Z][a-z]{6,13}$/}$$

-----

## Desglose y Explicaci√≥n de la Expresi√≥n Regular

La expresi√≥n se construye combinando **anclajes**, **grupos** y **lookaheads** para asegurar que se cumplan todas las condiciones de longitud, formato y contenido.

| Componente | Descripci√≥n | Cumple con |
| :--- | :--- | :--- |
| **`^`** | Ancla la b√∫squeda al **inicio** de la cadena. | |
| **`(?=.*[0-9])`** | **Lookahead positivo** (b√∫squeda avanzada): Asegura que, en cualquier punto de la cadena, exista **al menos un d√≠gito** (`[0-9]`). | *Debe contener al menos un n√∫mero.* |
| **`(?=.*[\*_\$\.\#\?\¬ø\-])`** | **Lookahead positivo** (b√∫squeda avanzada): Asegura que, en cualquier punto de la cadena, exista **al menos uno de los caracteres especiales** especificados. | *Debe contener al menos un car√°cter especial.* |
| **`[A-Z]`** | El primer car√°cter debe ser una **letra may√∫scula** (de la 'A' a la 'Z'). | *Debe iniciar con letra may√∫scula.* |
| **`[a-z]`** | El resto de los caracteres deben ser **letras min√∫sculas** (de la 'a' a la 'z'). | *El resto en min√∫scula.* |
| **`{6,13}`** | Cuantificador que aplica al bloque `[a-z]`. Indica que debe haber entre **6 y 13** caracteres min√∫sculos, sumado al car√°cter may√∫scula inicial, lo que cumple con la longitud total. | |
| **`$`** | Ancla la b√∫squeda al **final** de la cadena. | |

### Validaci√≥n de la Longitud

La longitud m√≠nima de 8 y m√°xima de 15 se asegura con:

  * **1** car√°cter inicial May√∫scula (`[A-Z]`).
  * **6 a 13** caracteres min√∫sculos restantes (`[a-z]{6,13}`).

$$\text{Longitud Total} = 1 + (6 \text{ a } 13) = 7 \text{ a } 14 \text{ caracteres}$$

**¬°Correcci√≥n Necesaria\!** üö® Para alcanzar los l√≠mites de 8 a 15, el cuantificador debe ser `{7,14}`:

$$\text{Longitud Total} = 1 + (7 \text{ a } 14) = 8 \text{ a } 15 \text{ caracteres}$$

-----

## Expresi√≥n Regular Final y Optimizada para JavaScript

Basado en la correcci√≥n de longitud, la expresi√≥n final es:

$$\text{/^(?=.*[0-9])(?=.*[\*_\$\.\#\?\¬ø\-])[A-Z][a-z0-9\*_\$\.\#\?\¬ø\-]{7,14}$/}$$

**¬°Atenci√≥n\!** La restricci√≥n "el resto en min√∫scula" entra en conflicto con las restricciones "debe contener al menos un n√∫mero" y "al menos un car√°cter especial". Un n√∫mero o car√°cter especial no es una letra min√∫scula.

**Asumo que el requisito de "el resto en min√∫scula" aplica al contenido alfab√©tico despu√©s del inicio, pero que se permite la inclusi√≥n de n√∫meros y caracteres especiales en las posiciones restantes.**

**Si la cadena restante solo puede tener min√∫sculas, la expresi√≥n original (corregida en longitud) es imposible de validar si se requieren n√∫meros y s√≠mbolos.**

### Opci√≥n 1: Cadena R√≠gida (La opci√≥n estricta que no permite n√∫meros/s√≠mbolos **excepto** en los lookaheads)

**Si tu intenci√≥n era que los lookaheads validaran *impl√≠citamente* el resto de la cadena, permitiendo que un n√∫mero o s√≠mbolo *sustituyera* a una min√∫scula en las posiciones siguientes:**

$$\text{/^(?=.*[0-9])(?=.*[\*_\$\.\#\?\¬ø\-])[A-Z][a-z]{7,14}$/}$$

  * Esta expresi√≥n es **IMPOSIBLE de validar** porque las posiciones 2 a 15 solo permiten `[a-z]`, pero los lookaheads exigen `[0-9]` y `[\*_\$\.\#\?\¬ø\-]` que no son min√∫sculas.

### Opci√≥n 2: Cadena Flexible (La opci√≥n m√°s com√∫n y funcional) ‚úÖ

**Esta es la versi√≥n funcional que respeta todas las condiciones (may√∫scula inicial, longitud, n√∫mero, s√≠mbolo) y asume que el "resto en min√∫scula" se refiere a que la mayor√≠a del contenido debe ser alfab√©tico min√∫sculo, pero permitiendo los caracteres requeridos por las otras reglas.**

$$\text{/^(?=.*[0-9])(?=.*[\*_\$\.\#\?\¬ø\-])[A-Z][a-z0-9\*_\$\.\#\?\¬ø\-]{7,14}$/}$$

  * **`[A-Z]`**: May√∫scula inicial.
  * **`[a-z0-9\*_\$\.\#\?\¬ø\-]`**: El resto de la cadena (7 a 14 caracteres) puede contener **min√∫sculas, n√∫meros y los s√≠mbolos especiales**.

### Ejemplo de Uso en JavaScript

```javascript
const regex = /^(?=.*[0-9])(?=.*[*_$.#?¬ø-])[A-Z][a-z0-9*_$.#?¬ø-]{7,14}$/;

console.log(regex.test("Aejemplo1*"));       // true (Longitud 10, cumple todo)
console.log(regex.test("Aejemplo123456789*")); // true (Longitud 15, m√°ximo)
console.log(regex.test("Aejemplo*"));        // false (No tiene n√∫mero)
console.log(regex.test("Aejemplo1"));        // false (No tiene s√≠mbolo)
console.log(regex.test("aejemplo1*"));       // false (No empieza con may√∫scula)
console.log(regex.test("Aejemplo1*M"));      // false (Contiene otra may√∫scula)
```

Una **expresi√≥n regular** (o *regex*, del ingl√©s *Regular Expression*) es una secuencia de caracteres que define un **patr√≥n de b√∫squeda**. üîé

Su funci√≥n principal es encontrar, validar o manipular cadenas de texto que sigan reglas espec√≠ficas. Es una herramienta fundamental en programaci√≥n y procesamiento de texto, utilizada para tareas como:

1.  **Validaci√≥n de Formatos**: Asegurar que un *email*, una *contrase√±a*, o un *n√∫mero de tel√©fono* cumplan con una estructura predefinida.
2.  **B√∫squeda y Extracci√≥n**: Encontrar todas las ocurrencias de una palabra o un patr√≥n complejo dentro de un texto grande.
3.  **Reemplazo de Texto**: Sustituir todas las coincidencias de un patr√≥n por otra cadena de texto.

---

## Componentes Clave

Una expresi√≥n regular est√° compuesta por caracteres literales (que coinciden consigo mismos, como `a`, `b`, `1`) y **metacaracteres** (caracteres especiales con significados de control):

| Metacar√°cter | Significado | Ejemplo |
| :--- | :--- | :--- |
| **`^`** | Inicio de la cadena. | `^A` busca una cadena que empiece por 'A'. |
| **`$`** | Final de la cadena. | `i√≥n$` busca una cadena que termine en 'i√≥n'. |
| **`.`** | Cualquier car√°cter (excepto salto de l√≠nea). | `a.b` coincide con 'a*b', 'a3b', 'acb'. |
| **`*`** | Cero o m√°s repeticiones del elemento anterior. | `ab*c` coincide con 'ac', 'abc', 'abbbc'. |
| **`+`** | Una o m√°s repeticiones del elemento anterior. | `ab+c` coincide con 'abc', 'abbbc', pero no con 'ac'. |
| **`?`** | Cero o una repetici√≥n (hace que el elemento sea opcional). | `colou?r` coincide con 'color' y 'colour'. |
| **`{n,m}`** | M√≠nimo $n$ y m√°ximo $m$ repeticiones. | `a{2,4}` coincide con 'aa', 'aaa', 'aaaa'. |
| **`[ ]`** | Define un **conjunto de caracteres** posibles. | `[aeiou]` coincide con cualquier vocal min√∫scula. |
| **`\d`** | Representa cualquier **d√≠gito** (`[0-9]`). | |
| **`\w`** | Representa cualquier car√°cter de **palabra** (letra, n√∫mero o guion bajo). | |

---

## Ejemplo Pr√°ctico

La expresi√≥n:
$$\text{/^\d{4}-\d{2}-\d{2}$/}$$

* **`^`** y **`$`**: Aseguran que el patr√≥n coincida con toda la cadena.
* **`\d{4}`**: Cuatro d√≠gitos (para el a√±o).
* **`-`**: Un guion literal.
* **`\d{2}`**: Dos d√≠gitos (para el mes y el d√≠a).

Esta expresi√≥n valida cadenas que tienen el formato de fecha **AAAA-MM-DD** (ejemplo: `2025-10-18`).

Aqu√≠ tienes una expresi√≥n regular que **solo admite letras may√∫sculas (A-Z) y espacios en blanco** dentro de una cadena.

$$\text{/^[A-Z\s]+$/}$$

-----

## Desglose de la Expresi√≥n Regular

Esta expresi√≥n regular es concisa y cumple estrictamente el requisito:

| Componente | Significado | Funci√≥n |
| :--- | :--- | :--- |
| **`^`** | Anclaje de inicio | Asegura que la coincidencia comience al **principio** de la cadena. |
| **`[`...`]`** | Conjunto de caracteres | Define qu√© caracteres est√°n permitidos. |
| **`A-Z`** | Rango de may√∫sculas | Permite cualquier letra de la **'A' a la 'Z'**. |
| **`\s`** | Metacar√°cter de espacio | Permite cualquier car√°cter de **espacio en blanco** (espacio, tabulaci√≥n, salto de l√≠nea). |
| **`+`** | Cuantificador | Indica que el conjunto de caracteres anterior (`[A-Z\s]`) debe aparecer **una o m√°s veces**. Esto tambi√©n asegura que la cadena no sea vac√≠a. |
| **`$`** | Anclaje de final | Asegura que la coincidencia termine al **final** de la cadena. |

## Ejemplo de Uso en JavaScript

```javascript
const regex = /^[A-Z\s]+$/;

// Cadenas que S√ç coinciden (TRUE)
console.log(regex.test("NOMBRE COMPLETO"));  // true
console.log(regex.test("SOLO MAYUSCULAS"));  // true
console.log(regex.test("HOLA"));             // true

// Cadenas que NO coinciden (FALSE)
console.log(regex.test("Tiene min√∫sculas")); // false (por las 'i', 'e', 'n', etc.)
console.log(regex.test("INCLUYE NUMEROS 123")); // false (por los '1', '2', '3')
console.log(regex.test("Con_Simbolos"));     // false (por el guion bajo)
console.log(regex.test(""));                 // false (el '+' requiere al menos 1 caracter)
```

Definir una expresi√≥n regular que valide **todos** los formatos de correo electr√≥nico posibles seg√∫n los est√°ndares (RFC 5322) es extremadamente complejo y resulta en una *regex* casi ilegible e ineficiente.

En la pr√°ctica de JavaScript, se utiliza una **expresi√≥n regular de compromiso** que cubre el **99%** de los formatos de correo electr√≥nico comunes y v√°lidos, sin la complejidad extrema de los casos raros.

Aqu√≠ est√° una de las *regex* m√°s utilizadas para la validaci√≥n de email en el desarrollo web:

$$\text{/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/}$$

---

## Desglose Detallado

La expresi√≥n se divide en tres partes principales: el nombre de usuario, el s√≠mbolo arroba (`@`), y el nombre de dominio.

### 1. Nombre de Usuario (Local Part): `[a-zA-Z0-9._%+-]+`

| Componente | Significado |
| :--- | :--- |
| **`[`...`]`** | Conjunto de caracteres permitidos. |
| **`a-zA-Z0-9`** | Permite letras **min√∫sculas, may√∫sculas** y **n√∫meros**. |
| **`._%+-`** | Permite los caracteres especiales comunes: **punto (`.`), guion bajo (`_`), porcentaje (`%`), signo m√°s (`+`) y guion medio (`-`)**. |
| **`+`** | Indica que el conjunto anterior debe aparecer **una o m√°s veces** (m√≠nimo un car√°cter). |

### 2. S√≠mbolo Arroba (`@`): `@`

| Componente | Significado |
| :--- | :--- |
| **`@`** | Coincide con el car√°cter arroba **literal**, que separa el nombre de usuario del dominio. |

### 3. Nombre de Dominio (Domain Part):